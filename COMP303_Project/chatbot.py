from dotenv import load_dotenv
from abc import ABC, abstractmethod
from typing import Type, Optional, TYPE_CHECKING
import os
import re
import requests
import sys

if any("server_remote" in arg for arg in sys.argv):
    from gevent import monkey; monkey.patch_all()
    from gevent import timeout
else:
    def timeout(x): 
        pass
    class Timeout(Exception): 
        pass

# Load environment variables from the .env file at the start
load_dotenv()
 
class ChatBot:
    __instance: Optional["ChatBot"] = None

    def __new__(cls: Type["ChatBot"]) -> "ChatBot":
        """
        Creates or retrieves the singleton instance of ChatBot.

        Args:
            cls (Type[ChatBot]): The class reference used to create or retrieve the singleton instance.

        Returns:
            ChatBot: The singleton instance of ChatBot. If an instance already exists, it returns the existing one.
        """
        if cls.__instance is None:
            cls.__instance = super(ChatBot, cls).__new__(cls)
        return cls.__instance
     
    def __init__(self) -> None:
        """
        Initializes the ChatBot instance by loading the API key from the environment variables.

        Raises:
            Exception: If the API key is not found in the environment.
        """
        self.api_key = os.getenv("OPEN_ROUTER_API_KEY")
        if self.api_key is None:
            raise Exception("Hmmm...API key was not found. Please try again.")
    
    @staticmethod
    def get_instance() -> "ChatBot":
        """
        Retrieves the singleton instance of ChatBot.

        Returns:
            ChatBot: The singleton instance of ChatBot.
        """
        if ChatBot.__instance is None:
            ChatBot.__instance = ChatBot()
        return ChatBot.__instance
 
    def get_response(self, conversation_strategy: "ConversationStrategy", user_input: str) -> str:
        """
        Generates a chatbot response based on the provided conversation strategy and user input.

        Args:
            conversation_strategy (ConversationStrategy): The conversation strategy to use.
            user_input (str): The user's input message.

        Returns:
            str: The generated response from the language model.
        """
        prompt = (
            f"{conversation_strategy.start_conversation()} "
            f"Respond in a tone that is appropriate to this character as if they are talking to someone from this house {conversation_strategy.get_house()}"
            f"Only respond to the user's question, do not describe settings or environment. "
            f"All answers should only be dialogue. Limit the answers to 450 characters maximum, including spaces. "
            f"Do not italicize or bold any of the text, just words, no symbols. "
            f"If the question asked by the user is not relevant to Harry Potter universe, prompt the user to ask a relevant question. "
            f"All characters should use witty Harry Potter universe references when answering questions. "
            f"Answer the following: {user_input}"
        )

        # OpenRouter.ai API endpoint as per their documentation
        # Link: https://openrouter.ai/docs/quickstart
        url = "https://openrouter.ai/api/v1/chat/completions"
        headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json"
        }

        data = {
            "model": "deepseek/deepseek-chat-v3-0324:free",
            "messages": [
                {
                    "role": "user",
                    "content": prompt
                }
            ]
        }

        try:
            response = requests.post(url, headers=headers, json=data, timeout=5)
            response.raise_for_status()
            result = response.json()
            answer = result["choices"][0]["message"]["content"].strip()
            return answer
        except requests.exceptions.HTTPError as http_err:
            error_details = response.text
            return f"HTTP error occurred: {http_err}\nDetails: {error_details}"
        except Exception as e:
            return f"Error calling LLM via OpenRouter.ai: {e}"
        except Timeout:
            return f"Timeout after 5 seconds."
        
    def get_description(self, title: str) -> str:
        """
        Generates a creative description for a book with the given title by directly calling the LLM with a custom prompt.

        Args:
            title (str): The title of the book.

        Returns:
            str: A creative description generated by the language model.
        """
        prompt = (
            f"Imagine a fascinating narrative for a book titled: '{title}'. "
            f"Provide a creative, brief description that captures the essence and intrigue of the book. "
            f"Whatever the given title is, link the book to Harry Potter universe. "
            f"If it is not possible to create Harry Potter universe references, then ask the user to input a more theme-specific title. "
            f"Keep your answers to 350 characters maximum, including spaces. Do not return the count of characters. "
            f"Do not italicize or bold any of the text, just words, no symbols (do not use *, etc.). "
            f"Do not return your prompt thoughts, because you are interacting with the player directly, so the description should be the only thing returned."
        )

        # Same logic as in get_response method
        url = "https://openrouter.ai/api/v1/chat/completions"
        headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json"
        }

        data = {
            "model": "deepseek/deepseek-chat-v3-0324:free",
            "messages": [
                {
                    "role": "user",
                    "content": prompt
                }
            ]
        }
        
        try:
            with Timeout(5):
                response = requests.post(url, headers=headers, json=data)
                response.raise_for_status()  # Raise exception on HTTP error
                result = response.json()
                answer = result["choices"][0]["message"]["content"].strip()
                return answer
        except requests.exceptions.HTTPError as http_err:
            error_details = response.text
            return f"HTTP error occurred: {http_err}\nDetails: {error_details}"
        except Exception as e:
            return f"Error calling LLM via OpenRouter.ai: {e}"
        except Timeout:
            return f"Timeout after 5 seconds."


class ConversationStrategy(ABC):
    """
    Interface for objects that interact with the chatbot and require a customized conversation strategy.
    """
    def get_response(self, message: str) -> str:
        """
        Retrieves a response from the ChatBot based on the conversation strategy and user input.

        Args:
            message (str): The user input message.

        Returns:
            str: The ChatBot's generated response.
        """
        print(f"\n\nGETTING RESPONSE FOR /CHAT {message} WITH STRATEGY {self}, PASSING HOUSE {self.get_house()}\n\n")
        if not message.strip():
            return self._handle_empty_message()
        return ChatBot.get_instance().get_response(self, message.strip())

    @abstractmethod
    def _opening_message(self) -> str:
        """
        Provides the opening message for the conversation specific to the strategy.

        Returns:
            str: The opening message.
        """
        pass

    def _handle_empty_message(self) -> str:
        """
        Provides a default message when the user input is empty.

        Returns:
            str: A default message prompting the user to provide input.
        """
        return "It appears you didn't say anything. Please share your thoughts."

    def start_conversation(self) -> str:
        """
        Starts the conversation using the conversation strategy.

        Returns:
            str: The opening message of the conversation.
        """
        return self._opening_message()

    def get_house(self) -> str:
        """
        Extracts the house name from the conversation strategy class name.

        Returns:
            str: The extracted house name if found; otherwise, 'Unknown'.
        """
        class_name = self.__class__.__name__
        match = re.search(r'[A-Z][a-z]+$', class_name)
        print(f"CONVERSATIONSTRATEGY :: GET HOUSE GOT {match}")
        if match:
            return match.group(0)
        return "Unknown"


class NullConversationStrategy(ConversationStrategy):
    def get_response(self, message: str) -> str:
        return ""
    def start_conversation(self) -> str:
        return ""
    def get_house(self) -> str:
        return ""
    def _opening_message(self) -> str:
        return ""
    def _handle_empty_message(self) -> str:
        return ""


class DumbledoreConversationStrategy(ConversationStrategy, ABC):
    def _opening_message(self) -> str:
        return "Greetings, I am Albus Dumbledore. How may I assist you on your magical journey today?"


class DumbledoreConversationStrategyGryffindor(DumbledoreConversationStrategy):
    pass


class DumbledoreConversationStrategyHufflepuff(DumbledoreConversationStrategy):
    pass


class DumbledoreConversationStrategyRavenclaw(DumbledoreConversationStrategy):
    pass


class DumbledoreConversationStrategySlytherin(DumbledoreConversationStrategy):
    pass


class HermioneConversationStrategy(ConversationStrategy, ABC):
    def _opening_message(self) -> str:
        return "Hello, I'm Hermione Granger. I'm here to offer my advice. What would you like to discuss?"


class HermioneConversationStrategyGryffindor(HermioneConversationStrategy):
    pass


class HermioneConversationStrategyHufflepuff(HermioneConversationStrategy):
    pass


class HermioneConversationStrategyRavenclaw(HermioneConversationStrategy):
    pass


class HermioneConversationStrategySlytherin(HermioneConversationStrategy):
    pass


class PeevesConversationStrategy(ConversationStrategy, ABC):
    def _opening_message(self) -> str:
        return "Hehehe, it's Peeves here! Ready for some mischief and mayhem?"


class PeevesConversationStrategyGryffindor(PeevesConversationStrategy):
    pass


class PeevesConversationStrategyHufflepuff(PeevesConversationStrategy):
    pass


class PeevesConversationStrategyRavenclaw(PeevesConversationStrategy):
    pass


class PeevesConversationStrategySlytherin(PeevesConversationStrategy):
    pass


class SnapeConversationStrategy(ConversationStrategy, ABC):
    def _opening_message(self) -> str:
        return "I'm Severus Snape. Speak, if you must."


class SnapeConversationStrategyGryffindor(SnapeConversationStrategy):
    pass


class SnapeConversationStrategyHufflepuff(SnapeConversationStrategy):
    pass


class SnapeConversationStrategyRavenclaw(SnapeConversationStrategy):
    pass


class SnapeConversationStrategySlytherin(SnapeConversationStrategy):
    pass


class PensieveConversationStrategy(ConversationStrategy, ABC):
    def _opening_message(self) -> str:
        return "You are now delving into memories with the Pensieve. Share your thoughts."


class PensieveConversationStrategyGryffindor(PensieveConversationStrategy):
    pass


class PensieveConversationStrategyHufflepuff(PensieveConversationStrategy):
    pass


class PensieveConversationStrategyRavenclaw(PensieveConversationStrategy):
    pass


class PensieveConversationStrategySlytherin(PensieveConversationStrategy):
    pass
